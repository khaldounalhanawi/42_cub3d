/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cast_rays                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kalhanaw <kalhanaw@student.42berlin.de>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/01/16 17:29:54 by kalhanaw          #+#    #+#             */
/*   Updated: 2026/01/27 16:29:07 by kalhanaw         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "data_types.h"
#include "main.h"
#include <stdlib.h>
#include <math.h>
#include <stdio.h>

enum
{
	X,
	Y
};

void	set_initial_step(t_raycast *ray, double pos_x, double pos_y)
{
	if (ray->ray_dir_x < 0)
	{
		ray->step_x = -1;
		ray->side_dist_x = (pos_x - ray->map_x * UNIT_SIZE) * ray->delta_x;
	}
	else
	{
		ray->step_x = 1;
		ray->side_dist_x = ((ray->map_x + 1) * UNIT_SIZE - pos_x) * ray->delta_x;
	}
	if (ray->ray_dir_y < 0)
	{
		ray->step_y = -1;
		ray->side_dist_y = (pos_y - ray->map_y * UNIT_SIZE) * ray->delta_y;
	}
	else
	{
		ray->step_y = 1;
		ray->side_dist_y = ((ray->map_y + 1) * UNIT_SIZE - pos_y) * ray->delta_y;
	}
}

void	loop_dda(t_raycast *ray, t_map map)
{
	while (!ray->hit)
	{
		if (ray->side_dist_x < ray->side_dist_y)
		{
			ray->side_dist_x += ray->delta_x;
			ray->map_x += ray->step_x;
			ray->side = X;
		}
		else
		{
			ray->side_dist_y += ray->delta_y;
			ray->map_y += ray->step_y;
			ray->side = Y;
		}
		if (ray->map_x < 0 || ray->map_x >= map.width || ray->map_y < 0 || ray->map_y >= map.height)
		{
			ray->hit = 1;  // stop at map edge
			break;
		}
		if (map.grid[ray->map_y][ray->map_x] == '1')
			ray->hit = 1;
	}
}

double calculate_distance(t_game *game, t_raycast *ray, int x)
{
	double camera_x = 2.0 * x / (double)WIDTH - 1.0;
	double pos_x_map = game->player.pos_x / UNIT_SIZE;
	double pos_y_map = game->player.pos_y / UNIT_SIZE;
	double wall_distance;

	// starting map square
	ray->map_x = (int)pos_x_map;
	ray->map_y = (int)pos_y_map;

	// ray direction for this column
	ray->ray_dir_x = game->player.dir_x + game->player.plane_x * camera_x;
	ray->ray_dir_y = game->player.dir_y + game->player.plane_y * camera_x;

	// length of ray from one x or y side to next x or y side
	ray->delta_x = (ray->ray_dir_x == 0) ? 1e30 : fabs(1 / ray->ray_dir_x);
	ray->delta_y = (ray->ray_dir_y == 0) ? 1e30 : fabs(1 / ray->ray_dir_y);

	ray->hit = 0;
	set_initial_step(ray, pos_x_map, pos_y_map); // pass map units
	loop_dda(ray, *game->map);

	// perpendicular distance to wall
	if (ray->side == X)
		wall_distance = (ray->map_x - pos_x_map + (1 - ray->step_x) / 2.0) / ray->ray_dir_x;
	else
		wall_distance = (ray->map_y - pos_y_map + (1 - ray->step_y) / 2.0) / ray->ray_dir_y;

	return wall_distance;
}


void	calculate_draw_start_end(t_rayhit_info *ray_info)
{
	int	line_height;

	line_height = HEIGHT / ray_info->distance;
	ray_info->draw_start = -(line_height / 2) + (HEIGHT / 2);
	ray_info->draw_end = (line_height / 2) + (HEIGHT / 2);
}

void	set_wall_side(t_rayhit_info *ray_info, t_raycast ray)
{
	if (ray.side == X && ray.step_x < 0)
		ray_info->wall_side = west;
	if (ray.side == X && ray.step_x > 0)
		ray_info->wall_side = east;
	if (ray.side == Y && ray.step_y < 0)
		ray_info->wall_side = north;
	if (ray.side == Y && ray.step_y > 0)
		ray_info->wall_side = south;
}

void	get_position_on_texture (double pos_x, double pos_y, t_raycast ray, t_rayhit_info *ray_info)
{
	if (ray.side == X)
		ray_info->texture_x_pos = pos_y + (ray_info->distance * ray.ray_dir_y);
	else
		ray_info->texture_x_pos = pos_x + (ray_info->distance * ray.ray_dir_x);
	ray_info->texture_x_pos -= floor (ray_info->texture_x_pos);
}

void catch (t_raycast ray)
{

	printf ("hola %f\n", ray.delta_x);
	return;
}

t_rayhit_info	create_ray_hit(t_game *game, int x)
{
	t_rayhit_info	ray_info;
	t_raycast		ray;
	
	ray_info.distance = calculate_distance (game, &ray, x);
	calculate_draw_start_end (&ray_info);
	set_wall_side (&ray_info, ray);
	get_position_on_texture (game->player.pos_x, game->player.pos_y, ray, &ray_info);
	return (ray_info);
}

void	cast_rays (t_game *game)
{
	int	x;

	x = 0;
	while (x < WIDTH)
	{
		game->ray_hits[x] = create_ray_hit (game, x);
		x ++;
	}
	if (DEBUG)
	{
		x = 0;
		while (x < WIDTH)
	{
		printf ("%f ", game->ray_hits[x].distance);
		x ++;
	}
	}
}